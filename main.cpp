#include <limits>
#include <ctime>
#include <cstdlib>
#include <iomanip>
#include <fstream>
#include <sstream>
#include <iterator>
#include <algorithm>


#include "BSTree.h"

using namespace std;

void manuallyGeneratedGame();

void autoGeneratedGame();

void readFile();

void printIT(int *const *gameField, bool countZero);

void buildTree(int size, const vector<int> &gameFieldVector, TreeNode* myTree, TreeNode* root);

void buildStorage(vector<vector<int>>& zeroStorage,vector<size_t>& storage,int size,const vector<int> &gameFieldVector);

size_t zeroPosition(const vector<int> &gameFieldVector);

void test() {
    bool exportFile;
    ofstream gameFile;

    cout << "Do you want to export your results to a .txt file?\n";

    do{
        cout << "Enter (0) for no and (1) for yes\n";
        cin.clear();
        cin.ignore(numeric_limits<streamsize>::max(),'\n');
        cin >> exportFile;
    }while(cin.fail());
    if(exportFile){
        gameFile.open ("15-file.txt");
    }

    int existsStorage=0;
    int size;
    cout << "set the size of the puzzle\n";
    cin.clear();
    cin.ignore(numeric_limits<streamsize>::max(),'\n');
    cin >> size;

    vector<int> gameFieldVector;
    vector<size_t> storage;
    vector<vector<int>> zeroStorage;

    int number;

    for (int i = 0; i < size*size-1; i++){
        bool exists = true;
        do{
            do {
                cout << "Please choose a unique number for the " << i  << " position.\n";
                cin.clear();
                cin.ignore(numeric_limits<streamsize>::max(),'\n');
                cin >> number;

                if (number <= (size*size+size) && number >= 1){
                    if(std::find(gameFieldVector.begin(), gameFieldVector.end(),number)!=gameFieldVector.end()){
                        cout<<"Number "<<number << " already exists.\n";
                    }else{
                        gameFieldVector.push_back(number);
                        exists=false;
                    }
                }else{
                    cout<<"Number must be between "<<size*size+size << " and 1.\n";
                    exists = true;
                }
            }while(exists);
        }while(cin.fail());
    }
    gameFieldVector.push_back(0);

    int countVector=0;
    for (int x:gameFieldVector){
        cout << "| " << setw(2) << x << " |";
        gameFile << setw(2) << x << " ";
        countVector++;
        if (countVector==size){
            countVector=0;
            cout<<"\n";
            gameFile << "\n";
        }
    }
    gameFile << "\n";

    if (!gameFile.is_open())return;
    gameFile.close();

    size_t g = TreeNode::hash(gameFieldVector);

//    if (std::find(storage.begin(), storage.end(),g)!=storage.end()){
//        cout<<"in\n";
//        existsStorage++;
//    }
    storage.push_back(g);
    zeroStorage.push_back(gameFieldVector);

//    buildStorage(zeroStorage,storage,size,gameFieldVector);

    gameFieldVector.clear();

    int countZero=0;
    int countMoves=0;
    int continueRow=0;
    int continueCol=0;
    int reverseRow=0;
    int reverseCol=0;
    for (const vector<int>& o:zeroStorage){
//        for (int k:o){
//            cout << setw(2) << k;
//            countZero++;
//            if (countZero==size){
//                countZero=0;
//                cout<<"\n";
//            }
//        }
//        cout<< "\n";
        bool countZeroo=1;
        countMoves++;
        int continueRowCount=0;
        int reverseRowCount=0;
        for (int i = 0; i < size*size; i++) {
            if (o[i]+1 == o[i+1]){
                continueRowCount++;
            }
            if (continueRowCount == 3){
                continueRowCount = 0;
                continueRow++;
            }
            if(i>size*size-size){
                if (i == 0 && (o[i] + 1 == o[i+size]) &&
                    (o[i] + 2 == o[i+size*2]) && (o[i] + 3 == o[i+size*3])) {
                    continueCol++;
                }
            }

            if (o[i]-1 == o[i+1]){
                reverseRowCount++;
            }
            if (reverseRowCount == 3){
                reverseRowCount = 0;
                reverseRow++;
            }
            if (i == 0 && (o[i] - 1 == o[i + size]) &&
                (o[i] - 2 == o[i + 2]) && (o[i] - 3 == o[i + 3])) {
                reverseCol++;
            }

            if (countZeroo){ // for counting the line with 0 as well
                if (continueRowCount == 2 && o[i + 1] == 0) {
                    continueRow++;
                }
                if (i == 0 && o[i + 3] == 0 &&
                    ((o[i] + 1 == o[i + 1]) && (o[i] + 2 == o[i + 2]))) {
                    continueCol++;
                }
                if (reverseRowCount == 2 && o[i + 1] == 0) {
                    reverseRow++;
                }
                if (i == 0 && o[i + 3] == 0 &&
                    ((o[i] - 1 == o[i + 1]) && (o[i] - 2 == o[i + 2]))) {
                    reverseCol++;
                }
            }
        }
    }
    cout <<"row = " << continueRow <<"\n"
        "column = " << continueCol << "\n"
        "reverse row = "<< reverseRow << "\n"
        "reverse column = " << reverseCol << "\n\n";
    cout<< "There are " <<countMoves << " possible turns\n";
}

size_t zeroPosition(const vector<int> &gameFieldVector) {
    for (size_t i=0; i < gameFieldVector.size(); i++)
        if (gameFieldVector.at(i)==0)
            return i;
    return 0;
}

void buildStorage(vector<vector<int>>& zeroStorage, vector<size_t>& storage, int size, const vector<int> &gameFieldVector){
    size_t position = zeroPosition(gameFieldVector);

    if(position % size > 0){
        //left
        vector<int> gameFieldLeft = gameFieldVector;
        iter_swap(gameFieldLeft.begin() + position, gameFieldLeft.begin() + (position-1));
        size_t hashedLeft = TreeNode::hash(gameFieldLeft);
        if (!(std::find(storage.begin(), storage.end(), hashedLeft) != storage.end())) {
            storage.push_back(hashedLeft);
            if(zeroPosition(gameFieldLeft) == size*size-1)
                zeroStorage.push_back(gameFieldLeft);
            buildStorage(zeroStorage, storage, size, gameFieldLeft);
        }
    }
    if (position % size != (size-1) ) {
        //go right
        vector<int> gameFieldRight = gameFieldVector;
        iter_swap(gameFieldRight.begin() + position, gameFieldRight.begin() + (position+1));
        size_t hashedRight = TreeNode::hash(gameFieldRight);
        if (!(std::find(storage.begin(), storage.end(), hashedRight) != storage.end())) {
            storage.push_back(hashedRight);
            if(zeroPosition(gameFieldRight) == size*size-1)
                zeroStorage.push_back(gameFieldRight);
            buildStorage(zeroStorage, storage, size, gameFieldRight);
        }
    }
    if (position > (size-1)) {
        //go up
        vector<int> gameFieldUp = gameFieldVector;
        iter_swap(gameFieldUp.begin() + position, gameFieldUp.begin() + (position-size));
        size_t hashedUp = TreeNode::hash(gameFieldUp);
        if (!(std::find(storage.begin(), storage.end(), hashedUp) != storage.end())) {
            storage.push_back(hashedUp);
            if(zeroPosition(gameFieldUp) == size*size-1)
                zeroStorage.push_back(gameFieldUp);
            buildStorage(zeroStorage, storage, size, gameFieldUp);
        }
    }
    if (position < (size*size-size)) {
        //go down
        vector<int> gameFieldDown = gameFieldVector;
        iter_swap(gameFieldDown.begin() + position, gameFieldDown.begin() + (position+size));
        size_t hashedDown = TreeNode::hash(gameFieldDown);
        if (!(std::find(storage.begin(), storage.end(), hashedDown) != storage.end())) {
            storage.push_back(hashedDown);
            if(zeroPosition(gameFieldDown) == size*size-1)
                zeroStorage.push_back(gameFieldDown);
            buildStorage(zeroStorage, storage, size, gameFieldDown);
        }
    }
}

void buildTree(int size, const vector<int> &gameFieldVector, TreeNode* myTree, TreeNode* root) {
    vector<size_t> storage;
    size_t position = zeroPosition(gameFieldVector);

    if (position == size*size-1){
        cout<< "we got a zero\n";
    }

    if (position % size > 0){
//        //go left
		vector<int> gameFieldLeft = gameFieldVector;
        iter_swap(gameFieldLeft.begin() + position, gameFieldLeft.begin() + (position-1));
        size_t hashedLeft = TreeNode::hash(gameFieldLeft);
        if(TreeNode::ifNodeExists(root,hashedLeft)){
            //cout<<"no LEFT\n";
        }else{
            TreeNode* node = TreeNode::Insert(hashedLeft, myTree, LEFT);
            if (node)
                buildTree(size, gameFieldLeft, node, root);
        }
    }
    if (position % size != (size-1)) {
        //go right
        vector<int> gameFieldRight = gameFieldVector;
        iter_swap(gameFieldRight.begin() + position, gameFieldRight.begin() + (position+1));
        size_t hashedRight = TreeNode::hash(gameFieldRight);
        if(TreeNode::ifNodeExists(root,hashedRight)){
           // cout<<"no RIGHT\n";
        }else{
            TreeNode* node = TreeNode::Insert(hashedRight, myTree, RIGHT);
            if (node)
                buildTree(size, gameFieldRight, node, root);
        }
    }
    if (position > (size-1)) {
        //go up
        vector<int> gameFieldUp = gameFieldVector;
        iter_swap(gameFieldUp.begin() + position, gameFieldUp.begin() + (position-size));
        size_t hashedUp = TreeNode::hash(gameFieldUp);
        if(TreeNode::ifNodeExists(root,hashedUp)){
           // cout<<"no UP\n";
        }else{
            TreeNode* node = TreeNode::Insert(hashedUp, myTree, UP);
            if (node)
                buildTree(size, gameFieldUp, node, root);
        }
    }
    if (position < (size*size-size)) {
        //go DOWN
        vector<int> gameFieldDown = gameFieldVector;
        iter_swap(gameFieldDown.begin() + position, gameFieldDown.begin() + (position+size));
        size_t hashedDown = TreeNode::hash(gameFieldDown);
        if(TreeNode::ifNodeExists(root,hashedDown)){
            //cout<<"no DOWN\n";
        }else{
            TreeNode* node = TreeNode::Insert(hashedDown, myTree, DOWN);
            if (node)
                buildTree(size, gameFieldDown, node, root);
        }
    }
}

int main () {
    int x=0;
    bool valid=true;
    bool again=true;
    do{
        cout << "\nWhat do you want to do?\n\n";
        do{
            cout << "Choose between\n(1).Manually generating the game\n(2).Auto generating the game\n(3).Read a game from a file\n";

            cin >> x;
            if (!cin.good()) {
                cin.clear();
                cin.ignore(numeric_limits<streamsize>::max(), '\n');
                continue;
            }

            if (x==1){
                valid=false;
//                manuallyGeneratedGame();
                test();
            }
            if (x==2){
                valid = false;
                autoGeneratedGame();
            }
            if (x==3){
                valid = false;
                readFile();
            }
        }while(valid);
        cout << "Wanna go again?\n(1).Yes\n(0).No\n";
        cin.clear();
        cin.ignore(numeric_limits<streamsize>::max(), '\n');
        cin >> again;
    }while(again);
}

void manuallyGeneratedGame() {
    int size;
    cout << "set the size of the puzzle\n";
    cin.clear();
    cin.ignore(numeric_limits<streamsize>::max(),'\n');
    cin >> size;

    auto gameField = new int * [ size ];
    for (int i=0; i < size; i++)
        gameField[i] = new int [size];

    vector<int> gameFieldVector;

    bool exportFile;
    ofstream gameFile;

    cout << "Do you want to export your results to a .txt file?\n";

    do{
        cout << "Enter (0) for no and (1) for yes\n";
        cin.clear();
        cin.ignore(numeric_limits<streamsize>::max(),'\n');
        cin >> exportFile;
    }while(cin.fail());
    if(exportFile){
        gameFile.open ("15-file.txt");
    }

    int count=0;
    int number;
    for (int i = 0; i < size; i++){
        for(int j=0; j < size; j++){
            bool exists = true;
            if (count!=size*size-1){
                do {
                    do {
                        cout << "Please choose a unique number from 1-"<<size*size+size<<" for the " << i << "," << j << " position\n";
                        cin.clear();
                        cin.ignore(numeric_limits<streamsize>::max(),'\n');
                        cin >> number;

                        for (int ii = 0; ii < size; ii++){
                            for(int jj=0; jj < size; jj++){
                                int* currentElement = &(gameField[ii][jj]);
                                if (number >size*size+size || number < 1){
                                    cout << "Value must be between 1-"<<size*size+size<<"\n";
                                    exists =true;
                                    break;
                                }
                                if (*currentElement == number){
                                    cout << "Value exists " << *currentElement <<  endl;
                                    exists = true;
                                    break;
                                }else{
                                    exists = false;

                                }
                            }
                            if (exists)
                                break;
                        }
                        gameField[i][j] = number;//array
                    }while(exists);
                    gameFieldVector.push_back(number);
                }while(cin.fail());
                count++;
            }else{
                gameField[i][j] =0;
                gameFieldVector.push_back(0);
            }
        }
    }
    int countVector=0;
    for (int x:gameFieldVector){
        cout << "| " << setw(2) << x << " |";
        gameFile << setw(2) << x << " ";
        countVector++;
        if (countVector==4){
            countVector=0;
            cout<<"\n";
            gameFile << "\n";
        }
    }
    gameFile << "\n";
    if (!gameFile.is_open())return;
    gameFile.close();
}

void autoGeneratedGame() {
    int existsStorage=0;
    int size;
    cout << "set the size of the puzzles\n";
    cin.clear();
    cin.ignore(numeric_limits<streamsize>::max(),'\n');
    cin >> size;

    int puzzles;
    bool exportFile;
    ofstream gameFile;

    vector<int> gameFieldVector;
    vector<size_t> storage;

    do{
        cout << "How many puzzles do you want?\n";
        cin.clear();
        cin.ignore(numeric_limits<streamsize>::max(),'\n');
        cin >> puzzles;
    }while(cin.fail());

    cout << "Do you want to export your results to a .txt file?\n";

    do{
        cout << "Enter (0) for no and (1) for yes\n";
        cin.clear();
        cin.ignore(numeric_limits<streamsize>::max(),'\n');
        cin >> exportFile;
    }while(cin.fail());
    if(exportFile){
        gameFile.open ("15-file.txt");
    }
    cout << puzzles << ".\n";
    gameFile << puzzles <<"\n";

    srand(time(nullptr));

    for (int p = 0; p < puzzles; p++){
        cout << p+1 <<".\n";
        for (int i = 0; i < size*size-1; i++){
            bool exists = true;
            do {
                int randomval = rand() % (size*size+size);

                if (randomval <= (size*size+size) && randomval >= 1){
                    if(std::find(gameFieldVector.begin(), gameFieldVector.end(),randomval)!=gameFieldVector.end()){
                    }else{
                        gameFieldVector.push_back(randomval);
                        exists=false;
                    }
                }else exists = true;
            }while(exists);
        }
        gameFieldVector.push_back(0);
        int countVector=0;
        for (int x:gameFieldVector){
            cout << "| " << setw(2) << x << " |";
            gameFile << setw(2) << x << " ";
            countVector++;
            if (countVector==size){
                countVector=0;
                cout<<"\n";
                gameFile << "\n";
            }
        }
        gameFile << "\n";

        size_t x = TreeNode::hash(gameFieldVector);

        if (std::find(storage.begin(), storage.end(),x)!=storage.end()){
            cout<<"in\n";
            existsStorage++;
        }
        storage.push_back(x);
        gameFieldVector.clear();
    }
    if (!gameFile.is_open())return;
    gameFile.close();

    cout<< "\n" <<existsStorage<< " duplications\n";
}

void readFile() {
    auto gameField = new int * [ 4 ];
    for (int i=0; i < 4; i++)
        gameField[i] = new int [4]{0};

    vector<int> gameFieldVector;

    string x;
    string line;
    ifstream gameFile ("15-file.txt");

    int countRow=0;
    int countCol=0;

    int o;

    bool countZero;

    cout << "Do you want to count the empty block in a continuous line?\n";
    do{
        cout << "Enter (0) for no and (1) for yes\n";
        cin.clear();
        cin.ignore(numeric_limits<streamsize>::max(),'\n');
        cin >> countZero;
    }while(cin.fail());

    if (gameFile.is_open()){
        while ( getline (gameFile,line) ){
            for(int j = 0; j < line.length(); j++){
                if (line.length() == 12) {
                    x = line[j];
                    if (j > 0) {
                        if (line[j] != ' ' && line[j - 1] != ' ') {
                            o = stoi(line[j - 1] + x);
                            gameField[countRow][countCol] = o;
                            gameFieldVector.push_back(o);
                            if (countCol == 3) {
                                countCol = 0;
                            } else {
                                countCol++;
                            }
                        }
                        if (line[j] != ' ' && line[j + 1] == ' ' && line[j - 1] == ' ') {
                            o = stoi(x);
                            gameField[countRow][countCol] = o;
                            gameFieldVector.push_back(o);
                            if (countCol == 3) {
                                countCol = 0;
                            } else {
                                countCol++;
                            }
                        }
                    }
                }
            }

            if (line.length() == 0){
                printIT(gameField, countZero);
//                            int countVector=0;
//                            for (int p:gameFieldVector){
//                                cout << setw(2) << p << " ";
//                                countVector++;
//                                if (countVector==4){
//                                    countVector=0;
//                                    cout<<"\n";
//                                }
//                            }
//                            cout << "\n";
//                            for (int p :gameFieldVector){
//                                gameFieldVector.pop_back();
//                            }
            }

            if (line.length() == 12) {
                if (countRow == 3) {
                    countRow = 0;
                } else {
                    countRow++;
                }
            }
        }
        gameFile.close();
    } else cout << "Unable to open file";
	for (int i = 0; i < 4; i++) {
		delete[] gameField[i];
	}
	delete[] gameField;
}

void printIT(int *const *gameField, bool countZero) {

    int continueRow=0;
    int continueCol=0;
    int reverseRow=0;
    int reverseCol=0;
    for (int i = 0; i < 4; i++) {
        int continueRowCount=0;
        int reverseRowCount=0;
        for (int p = 0; p < 4; p++) {
            cout << setw(2) << gameField[i][p]<< " ";

            if (gameField[i][p]+1 == gameField[i][p+1]){
                continueRowCount++;
            }
            if (continueRowCount == 3){
                continueRowCount = 0;
                continueRow++;
            }
            if (i == 0 && (gameField[0][p] + 1 == gameField[0 + 1][p]) &&
                (gameField[0][p] + 2 == gameField[0 + 2][p]) && (gameField[0][p] + 3 == gameField[0 + 3][p])) {
                continueCol++;
            }
            if (gameField[i][p]-1 == gameField[i][p+1]){
                reverseRowCount++;
            }
            if (reverseRowCount == 3){
                reverseRowCount = 0;
                reverseRow++;
            }
            if (i == 0 && (gameField[0][p] - 1 == gameField[0 + 1][p]) &&
                (gameField[0][p] - 2 == gameField[0 + 2][p]) && (gameField[0][p] - 3 == gameField[0 + 3][p])) {
                reverseCol++;
            }

            if (countZero){ // for counting the line with 0 as well
                if (continueRowCount == 2 && gameField[i][p + 1] == 0) {
                    continueRow++;
                }
                if (i == 0 && gameField[0 + 3][p] == 0 &&
                    ((gameField[0][p] + 1 == gameField[0 + 1][p]) && (gameField[0][p] + 2 == gameField[0 + 2][p]))) {
                    continueCol++;
                }
                if (reverseRowCount == 2 && gameField[i][p + 1] == 0) {
                    reverseRow++;
                }
                if (i == 0 && gameField[0 + 3][p] == 0 &&
                    ((gameField[0][p] - 1 == gameField[0 + 1][p]) && (gameField[0][p] - 2 == gameField[0 + 2][p]))) {
                    reverseCol++;
                }
            }
        }
        cout << "\n";
    }
    cout <<"row = " << continueRow <<"\n"
           "column = " << continueCol << "\n"
           "reverse row = "<< reverseRow << "\n"
           "reverse column = " << reverseCol << "\n\n";
}
