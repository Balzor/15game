#include <limits>
#include <ctime>
#include <cstdlib>
#include <iomanip>
#include <fstream>
#include <sstream>
#include <iterator>
#include <algorithm>

#include "Puzzles.h"

using namespace std;

void manualGame();

void autoGeneratedGame();

void readFile();

void buildStorage(vector<vector<int>>& zeroStorage,vector<size_t>& storage,int size,const vector<int> &gameFieldVector,int turns,int &turnCounter);

size_t zeroPosition(const vector<int> &gameFieldVector);

int findContinuities(int size, const vector<vector<int>> &zeroStorage, bool countZeroo,string& solution);

void showSolution(string &solution, int &existsStorage, int size, vector<int> &gameFieldVector, vector<size_t> &storage,vector<vector<int>> &zeroStorage, bool countZeroo, int turns, int turnCounter);

void userInput(ofstream &gameFile, ofstream &solutionFile, int &size, bool &repeat);

void continuitySettings(int &turns, bool &countZeroo);

int main () {
    int x=0;
    bool valid=true;
    bool again=true;
    do{
        cout << "\nWhat do you want to do?\n\n";
        do{
            cout << "Choose between\n(1).Manually generating the game\n(2).Auto generating the game\n(3).Read a game from a file\n";
            cin >> x;
            if (!cin.good()) {
                cin.clear();
                cin.ignore(numeric_limits<streamsize>::max(), '\n');
                continue;
            }
            if (x==1){
                valid=false;
                manualGame();
            }
            if (x==2){
                valid = false;
                autoGeneratedGame();
            }
            if (x==3){
                valid = false;
                readFile();
            }
        }while(valid);
        do{
            cout << "Wanna go again?\n(1).Yes\n(0).No\n";
            cin.clear();
            cin.ignore(numeric_limits<streamsize>::max(), '\n');
            cin >> again;
        }while(cin.fail());
    }while(again);
}

void manualGame() {
    string solution;
    int existsStorage;

    ofstream gameFile;
    ofstream solutionFile;
    int size;
    bool repeat;
    userInput(gameFile, solutionFile, size, repeat);

    vector<int> gameFieldVector;
    vector<size_t> storage;
    vector<vector<int>> zeroStorage;

    int number;

    for (int i = 0; i < size*size-1; i++){
        bool exists = true;
        do{
            do {
                cout << "Please choose a unique number from 1-"<<size*size+size<<" for the "<< i  << " position.(if you have no repeat ON)\n";
                cin.clear();
                cin.ignore(numeric_limits<streamsize>::max(),'\n');
                cin >> number;

                if(repeat){
                    gameFieldVector.push_back(number);
                    exists=false;
                }else{
                    if (number <= (size*size+size) && number >= 1){
                        if(std::find(gameFieldVector.begin(), gameFieldVector.end(),number)!=gameFieldVector.end()){
                            cout<<"Number "<<number << " already exists.\n";
                        }else{
                            gameFieldVector.push_back(number);
                            exists=false;
                        }
                    }else{
                        cout<<"Number must be between "<<size*size+size << " and 1.\n";
                        exists = true;
                    }
                }
            }while(exists);
        }while(cin.fail());
    }
    gameFieldVector.push_back(0);

    int countVector=0;
    for (int x:gameFieldVector){
        cout << "| " << setw(2) << x << " |";
        gameFile << setw(2) << x << " ";
        solutionFile << setw(2) << x << " ";
        countVector++;
        if (countVector==size){
            countVector=0;
            cout<<"\n";
            gameFile << "\n";
            solutionFile << "\n";
        }
    }
    gameFile << "\n";
    int turnCounter=1;

    int turns;
    bool countZeroo;
    continuitySettings(turns, countZeroo);

    showSolution(solution, existsStorage, size, gameFieldVector, storage, zeroStorage, countZeroo,turns,turnCounter);

    solutionFile << solution;

    if (!gameFile.is_open())return;
    gameFile.close();
    if (!solutionFile.is_open())return;
    solutionFile.close();
}

void autoGeneratedGame() {
    string solution;
    int existsStorage=0;

    vector<int> gameFieldVector;
    vector<size_t> storage;
    vector<vector<int>> zeroStorage;
    ofstream gameFile;
    ofstream solutionFile;
    int size;
    bool repeat;
    userInput(gameFile, solutionFile, size, repeat);

    int puzzles;
    do{
        cout << "How many puzzles do you want?\n";
        cin.clear();
        cin.ignore(numeric_limits<streamsize>::max(),'\n');
        cin >> puzzles;
    }while(cin.fail());

    cout << puzzles << ".\n";
    gameFile << puzzles <<"\n";
    solutionFile<<puzzles<<"\n";

    int turns;
    bool countZeroo=true;
    continuitySettings(turns, countZeroo);

    srand(time(nullptr));

    for (int p = 0; p < puzzles; p++){
        cout << p+1 <<".\n";
        for (int i = 0; i < size*size-1; i++){
            bool exists = true;
            do {
                int randomval = rand() % (size*size+size);

                if (repeat){
                    if (randomval>=1){
                        gameFieldVector.push_back(randomval);
                        exists=false;
                    }else   exists=true;
                }else{
                    if (randomval <= (size*size+size) && randomval >= 1){
                        if(std::find(gameFieldVector.begin(), gameFieldVector.end(),randomval)!=gameFieldVector.end()){
                        }else{
                            gameFieldVector.push_back(randomval);
                            exists=false;
                        }
                    }else exists = true;
                }
            }while(exists);
        }
        gameFieldVector.push_back(0);
        int countVector=0;
        for (int x:gameFieldVector){
            cout << "| " << setw(2) << x << " |";
            gameFile << setw(2) << x << " ";
            solutionFile << setw(2) << x << " ";
            countVector++;
            if (countVector==size){
                countVector=0;
                cout<<"\n";
                gameFile << "\n";
                solutionFile << "\n";
            }
        }
        gameFile << "\n";

        int turnCounter=1;

        showSolution(solution, existsStorage, size, gameFieldVector, storage, zeroStorage, countZeroo,turns,turnCounter);

        solutionFile << solution;
    }
    if (!gameFile.is_open())return;
    gameFile.close();
    if (!solutionFile.is_open())return;
    solutionFile.close();

    cout<< "\n" <<existsStorage<< " duplications\n";
}

void readFile() {
    vector<int> gameFieldVector;
    vector<vector<int>> zeroStorage;
    vector<size_t> storage;

    int existsStorage;
    string x;
    string line;
    string solution;
    ifstream gameFile ("15-file.txt");

    int o;
    int size;
    do{
        cout << "What is the size of the puzzles to read?\n";
        cout << "2, 3, 4 etc...\n";
        cin.clear();
        cin.ignore(numeric_limits<streamsize>::max(),'\n');
        cin >> size;
    }while(cin.fail());

    int turns;
    bool countZero;
    continuitySettings(turns, countZero);

    if (gameFile.is_open()){
        while ( getline (gameFile,line) ){
            for(unsigned int j = 0; j < line.length(); j++){
                if (line.length() >=6) {
                    x = line[j];
                    if (j > 0) {
                        if (line[j] != ' ' && line[j - 1] != ' ') {
                            o = stoi(line[j - 1] + x);
                            gameFieldVector.push_back(o);
                        }
                        if (line[j] != ' ' && line[j + 1] == ' ' && line[j - 1] == ' ') {
                            o = stoi(x);
                            gameFieldVector.push_back(o);
                        }
                    }
                }
            }
            if (line.length() == 0){
                int countVector=0;
                for (int v:gameFieldVector){
                    cout << "| " << setw(2) << v << " |";
                    countVector++;
                    if (countVector==size){
                        countVector=0;
                        cout<<"\n";
                    }
                }
                int turnCounter=1;

                showSolution(solution, existsStorage, size, gameFieldVector, storage, zeroStorage, countZero,turns,turnCounter);
            }
        }
        gameFile.close();
    } else cout << "Unable to open file";
}

void userInput(ofstream &gameFile, ofstream &solutionFile, int &size, bool &repeat) {
    bool exportFile;
    do{
        cout << "Do you want to create a 15-file.txt file?\n";
        cout << "Enter (0) for no and (1) for yes\n";
        cin.clear();
        cin.ignore(numeric_limits<streamsize>::max(),'\n');
        cin >> exportFile;
    }while(cin.fail());
    if(exportFile){
        gameFile.open ("15-file.txt");
    }
    bool exportSolution;
    do{
        cout << "Do you want to create a solution file?\n";
        cout << "Enter (0) for no and (1) for yes\n";
        cin.clear();
        cin.ignore(numeric_limits<streamsize>::max(),'\n');
        cin >> exportSolution;
    }while(cin.fail());
    if(exportSolution){
        solutionFile.open ("Solution-file.txt");
    }
    do{
        cout << "set the size of the puzzles\n";
        cin.clear();
        cin.ignore(numeric_limits<streamsize>::max(),'\n');
        cin >> size;
    }while(cin.fail());
    do{
        cout << "Do you want repeat numbers\n(1).Yes\n(0).No\n";
        cin.clear();
        cin.ignore(numeric_limits<streamsize>::max(),'\n');
        cin >> repeat;
    }while(cin.fail());
}

void continuitySettings(int &turns, bool &countZeroo) {
    bool continuities;
    do{
        cout<<"Do you want to see all possible continuities?\n(1).Yes\n(0).No\n";
        cin.clear();
        cin.ignore(numeric_limits<streamsize>::max(),'\n');
        cin>>continuities;
    }while(cin.fail());
    if(!continuities){
        cout<<"How many turns do you want calculated?\n";
        cin.clear();
        cin.ignore(numeric_limits<streamsize>::max(),'\n');
        cin>>turns;
    }else{
        turns=0;
    }
    do{
        cout<<"Do you want to count the empty as a continuity?\n(1).Yes\n(0).No\n";
        cin.clear();
        cin.ignore(numeric_limits<streamsize>::max(),'\n');
        cin>>countZeroo;
    }while(cin.fail());
}

size_t zeroPosition(const vector<int> &gameFieldVector) {
    for (size_t i=0; i < gameFieldVector.size(); i++)
        if (gameFieldVector.at(i)==0)
            return i;
    return 0;
}

void buildStorage(vector<vector<int>>& zeroStorage, vector<size_t>& storage, int size, const vector<int> &gameFieldVector,int turns,int &turnCounter){
    size_t position = zeroPosition(gameFieldVector);
    if((turnCounter<turns) || (turns==0)){
        if(position % size > 0){
            vector<int> gameFieldLeft = gameFieldVector;
            iter_swap(gameFieldLeft.begin() + position, gameFieldLeft.begin() + (position-1));
            size_t hashedLeft = Puzzles::hash(gameFieldLeft);
            if (!(std::find(storage.begin(), storage.end(), hashedLeft) != storage.end())) {
                storage.push_back(hashedLeft);
                if((turnCounter<turns) || (turns==0)){
                    buildStorage(zeroStorage, storage, size, gameFieldLeft,turns,turnCounter);
                }
            }
        }
        if (position % size != (size-1) ) {
            vector<int> gameFieldRight = gameFieldVector;
            iter_swap(gameFieldRight.begin() + position, gameFieldRight.begin() + (position+1));
            size_t hashedRight = Puzzles::hash(gameFieldRight);
            if (!(std::find(storage.begin(), storage.end(), hashedRight) != storage.end())) {
                storage.push_back(hashedRight);
                if((turnCounter<turns) || (turns==0)){
                    if(zeroPosition(gameFieldRight) == size*size-1){
                        zeroStorage.push_back(gameFieldRight);
                        turnCounter++;
                    }
                    buildStorage(zeroStorage, storage, size, gameFieldRight,turns,turnCounter);
                }
            }
        }
        if (position > (size-1)) {
            vector<int> gameFieldUp = gameFieldVector;
            iter_swap(gameFieldUp.begin() + position, gameFieldUp.begin() + (position-size));
            size_t hashedUp = Puzzles::hash(gameFieldUp);
            if (!(std::find(storage.begin(), storage.end(), hashedUp) != storage.end())) {
                storage.push_back(hashedUp);
                if((turnCounter<turns) || (turns==0)){
                    buildStorage(zeroStorage, storage, size, gameFieldUp,turns,turnCounter);
                }
            }
        }
        if (position < (size*size-size)) {
            vector<int> gameFieldDown = gameFieldVector;
            iter_swap(gameFieldDown.begin() + position, gameFieldDown.begin() + (position+size));
            size_t hashedDown = Puzzles::hash(gameFieldDown);
            if (!(std::find(storage.begin(), storage.end(), hashedDown) != storage.end())) {
                storage.push_back(hashedDown);
                if((turnCounter<turns) || (turns==0)){
                    if(zeroPosition(gameFieldDown) == size*size-1){
                        zeroStorage.push_back(gameFieldDown);
                        turnCounter++;
                    }
                    buildStorage(zeroStorage, storage, size, gameFieldDown,turns,turnCounter);
                }
            }
        }
    }
}

int findContinuities(int size, const vector<vector<int>> &zeroStorage, bool countZeroo,string& solution) {
    int countMoves=0;
    int continueRow=0;
    int continueCol=0;
    int reverseRow=0;
    int reverseCol=0;
    int twoPartial=0;
    int threePartial=0;
    for (const vector<int>& o:zeroStorage){
        countMoves++;
        int continueRowCount=0;
        int reverseRowCount=0;
        int continueColCount =0;
        int reverseColCount =0;
        int counting=0;
        int threePartialCountCont=0;
        int threePartialCountRev=0;
        int threePartialColCount=0;
        int threePartialRevCol=0;
        for (int i = 0; i < size*size-1; i++) {
            if (!((o[i+1] ==0 ) || (o[i]==0))){
                if (i % size != (size-1)) {
                    if (o[i] + 1 == o[i + 1]) {
                        continueRowCount++;
                        twoPartial++;
                        threePartialCountCont++;
                    }
                    if (o[i] - 1 == o[i + 1]) {
                        reverseRowCount++;
                        twoPartial++;
                        threePartialCountRev++;
                    }
                    if (threePartialCountCont == 2){
                        threePartial++;
                    }
                    if (threePartialCountRev == 2){
                        threePartial++;
                    }
                    if (threePartialCountCont == 3){
                        threePartial++;
                    }
                    if (threePartialCountRev == 3){
                        threePartial++;
                    }
                }

                if (continueRowCount == size-1){
                    continueRowCount = 0;
                    continueRow++;
                }
                if (reverseRowCount == size-1){
                    reverseRowCount = 0;
                    reverseRow++;
                }

                if(i<=((size*size)-size-1)){
                    if(o[i]+1==o[i+size]){
                        continueColCount++;
                        twoPartial++;
                        threePartialColCount++;
                    }
                    if(o[i]-1==o[i+size]){
                        reverseColCount++;
                        twoPartial++;
                        threePartialRevCol++;
                    }
                    if (threePartialColCount == 2){
                        threePartial++;
                    }
                    if (threePartialRevCol == 2){
                        threePartial++;
                    }
                    if (threePartialColCount == 3){
                        threePartial++;
                    }
                    if (threePartialRevCol == 3){
                        threePartial++;
                    }
                }

                if (continueColCount == size-1){
                    continueColCount = 0;
                    continueCol++;
                }
                if (reverseColCount == size-1){
                    reverseColCount = 0;
                    reverseCol++;
                }
            }

            if (countZeroo){
                if(o[i+1]==0){
                    twoPartial++;
                    if (threePartialCountCont == 2){
                        threePartial++;
                    }
                    if (threePartialCountRev == 2){
                        threePartial++;
                    }
                    if (threePartialCountCont == 3){
                        threePartial++;
                    }
                    if (threePartialCountRev == 3){
                        threePartial++;
                    }
                }
                if ((continueRowCount == (size-2)) && (o[i + 1] == 0)) {
                    continueRow++;
                }
                if ((reverseRowCount == (size-2)) && (o[i + 1] == 0)) {
                    reverseRow++;
                }
                if(i<=((size*size)-size-1)){
                    if (o[i+size]==0){
                        twoPartial++;
                        if (threePartialColCount == 2){
                            threePartial++;
                        }
                        if (threePartialRevCol == 2){
                            threePartial++;
                        }
                        if (threePartialColCount == 3){
                            threePartial++;
                        }
                        if (threePartialRevCol == 3){
                            threePartial++;
                        }
                    }

                    if((reverseColCount == (size-2)) && o[i+size]==0){
                        reverseCol++;
                    }
                    if((continueColCount == (size-2)) && o[i+size]==0){
                        continueCol++;
                    }
                }
            }

            counting++;
            if (counting==size){
                continueRowCount=0;
                reverseRowCount=0;
                threePartialCountCont=0;
                threePartialCountRev=0;
                threePartialColCount=0;
                threePartialRevCol=0;
                counting=0;
            }
        }
    }
    solution = "row = " + to_string(continueRow) +"\n"
                                                  "column = " + to_string(continueCol) + "\n"
                                                                                         "reverse row = "+ to_string(reverseRow) + "\n"
                                                                                                                                   "reverse column = " + to_string(reverseCol) + "\n"
                                                                                                                                                                                 "2-partial = "+ to_string(twoPartial)+ "\n"
                                                                                                                                                                                                                        "3-partial = "+to_string(threePartial)+ "\n\n";
    return countMoves;
}

void showSolution(string &solution, int &existsStorage, int size, vector<int> &gameFieldVector, vector<size_t> &storage, vector<vector<int>> &zeroStorage, bool countZeroo, int turns, int turnCounter) {
    size_t x = Puzzles::hash(gameFieldVector);
    if (find(storage.begin(), storage.end(), x) != storage.end()){
        existsStorage++;
    }
    storage.push_back(x);
    zeroStorage.push_back(gameFieldVector);
    buildStorage(zeroStorage,storage,size,gameFieldVector,turns,turnCounter);
    int countMoves = findContinuities(size, zeroStorage, countZeroo,solution);
    cout<<solution;
    cout<< "Results for " <<countMoves << " calculated turns\n";
    gameFieldVector.clear();
    zeroStorage.clear();
    storage.clear();
}